---
id: 82
title: 'DISTRIBUTED SYSTEMS: LECTURE 4'
date: 2015-11-02T11:53:00+00:00
author: chito
layout: post
guid: http://www.afriqueunique.org/2015/11/02/11942327/
permalink: /2015/11/02/11942327/
swp_pinterest_image_url:
  - ""
swp_cache_timestamp:
  - "426351"
post_views_count:
  - "152"
bs_social_share_facebook:
  - "0"
bs_social_share_twitter:
  - "0"
bs_social_share_reddit:
  - "0"
bs_social_share_google_plus:
  - "0"
bs_social_share_linkedin:
  - "0"
bs_social_share_interval:
  - "1568563813"
categories:
  - LEARNING
---
<span style="font-size:small;">Distributed Systems Fö 4 &#8211; 1<br />Petru Eles, IDA, LiTH<br /><strong>DISTRIBUTED HETEROGENEOUS</strong><br /><strong>APPLICATIONS AND CORBA</strong><br /><strong>1. Heterogeneity in Distributed Systems</strong><br /><strong>2. Middleware</strong><br /><strong>3. Objects in Distributed Systems</strong><br /><strong>4. The CORBA Approach</strong><br /><strong>5. Components of a CORBA Environment</strong><br /><strong>6. CORBA Services</strong><br />Distributed Systems Fö 4 &#8211; 2<br />Petru Eles, IDA, LiTH<br /><strong>Heterogeneity in Distributed Systems</strong><br />☞ Distributed applications are typically heterogeneous:<br />&#8211; different hardware: mainframes, workstations,<br />PCs, servers, etc.;<br />&#8211; different software: UNIX, MS Windows, IBM OS/2,<br />Real-time OSs, etc.;<br />&#8211; unconventional devices: teller machines,<br />telephone switches, robots, manufacturing<br />systems, etc.;<br />&#8211; diverse networks and protocols: Ethernet,<br />FDDI, ATM, TCP/IP, Novell Netware, etc.<br />☞ Why?<br />&#8211; Different hardware/software solutions are<br />considered to be optimal for different parts of<br />the system.<br />&#8211; Different users which have to interact are<br />deciding for different hardware/software<br />solutions/vendors.<br />&#8211; <strong>Legacy systems</strong>.<br />Distributed Systems Fö 4 &#8211; 3<br />Petru Eles, IDA, LiTH<br /><strong>Middleware</strong><br />☞ A key component of a heterogeneous distributed<br />client-server environment is <em>middleware</em>.<br />• <em>Middleware</em> is a set of services that enable<br />applications and end users to interact with each<br />other across a heterogeneous distributed system.<br />Middleware software resides above the network<br />and below the application software.<br />Network<br />Middleware Middleware Middleware Middleware<br />User Application Application User<br />Distributed Systems Fö 4 &#8211; 4<br />Petru Eles, IDA, LiTH<br /><strong>Middleware (cont’d)</strong><br />• Middleware should make the network transparent<br />to the applications and end users ⇒ users and<br />applications should be able to perform the same<br />operations across the network that they can<br />perform locally.<br />• Middleware should hide the details of computing<br />hardware, OS, software components across<br />networks.<br />• Different kind of software qualifies, to certain<br />extent, as middleware:<br />&#8211; File-transfer packages (FTP) and email;<br />&#8211; Web browsers;<br />&#8211; CORBA<br />Distributed Systems Fö 4 &#8211; 5<br />Petru Eles, IDA, LiTH<br /><strong>Objects in Distributed Systems</strong><br />• A distributed application can be viewed as a<br />collection of objects (user interfaces, databases,<br />application modules, customers).<br />Client Objects Server Objects<br />Object Request Broker (ORB)<br />Object Services<br />Middleware<br />Distributed Systems Fö 4 &#8211; 6<br />Petru Eles, IDA, LiTH<br /><strong>Objects in Distributed Systems (cont’d)</strong><br />• Objects are data surrounded by code; each one<br />has its own attributes and methods which define<br />the behavior of the object; objects can be clients,<br />servers, or both.<br />• Middleware:<br />&#8211; Object brokers allow objects to find each other<br />in a distributed system and interact with each<br />other over a network; they are the backbone of<br />the distributed object-oriented system.<br />&#8211; Object services allow to create, name, move,<br />copy, store, delete, restore, and manage<br />objects.<br />• Modeling in terms of OO concepts does not<br />necessarily imply use of OO programming<br />languages for implementation or the use of OO<br />database managers as part of the system.<br />Distributed Systems Fö 4 &#8211; 7<br />Petru Eles, IDA, LiTH<br /><strong>Objects in Distributed Systems (cont’d)</strong><br />If we relate to the picture in Lecture 3, slide 10, which<br />explains RMI, we can recognize some components:<br />• We have the client and server objects.<br />• We have the skeleton and proxy, which are on the<br />border between middleware and application.<br />• The <em>communication module</em> and the <em>remote</em><br /><em>reference module</em> are part of the ORB.<br />☞ Additional components which are part of the<br />middleware:<br />&#8211; Object adapter<br />&#8211; Implementation repository<br />&#8211; Interface repository.<br />Distributed Systems Fö 4 &#8211; 8<br />Petru Eles, IDA, LiTH<br /><strong>Client</strong><br />Object A Proxy for B<br /><strong>Server</strong><br />Skeleton for B Object B<br />Request<br />Reply<br />Object adapter<br />ORB ORB<br />Implementation<br />repository<br />Interface<br />repository<br /><strong>Objects in Distributed Systems (cont’d)</strong><br />Distributed Systems Fö 4 &#8211; 9<br />Petru Eles, IDA, LiTH<br /><strong>Interface Definition Language</strong><br />☞ An <strong>interface</strong> specifies the API (Application<br />Programming Interface) that the clients can use to<br />invoke operations on objects:<br />&#8211; the set of operations<br />&#8211; the parameters needed to perform the operations.<br />• One or more interfaces can be defined for an<br />object. Such, different interfaces can be defined for<br />different classes of users of the same object.<br />• Interfaces are defined by using an <strong>interface</strong><br /><strong>definition language</strong> (IDL).<br /><em>CORBA IDL</em> is an example of such a language.<br />Distributed Systems Fö 4 &#8211; 10<br />Petru Eles, IDA, LiTH<br /><strong>Interface Definition Language (cont’d)</strong><br />☞ Middleware products (such as CORBA) provide<br />interface compilers that parse the IDL description of<br />the interface. Such a compiler produces the code<br />which represents:<br />&#8211; the classes corresponding to the <em>proxies</em> (in the<br />language of the client).<br />&#8211; the classes corresponding to the <em>skeletons</em> (in<br />the language of the server).<br />• If the client or the server are not in an object<br />oriented language, the compiler generates a client<br />stub (instead of proxy class) respectively server<br />stub (instead of skeleton class).<br />☞ IDLs are declarative languages; they do not specify<br />any executable code, but only declarations.<br />☞ IDLs should be implementation language<br />independent ⇒ the interface is defined independent<br />of the language in which the server and its clients are<br />implemented.<br /><em>Language mappings</em> have to be defined which allow<br />to compile the IDL interface and to generate proxies<br />and skeletons in the implementation languages of the<br />clients and of the server respectively.<br />Distributed Systems Fö 4 &#8211; 11<br />Petru Eles, IDA, LiTH<br /><strong>CORBA</strong><br />☞ Object Management Group (OMG): a non-profit<br />industry consortium formed in 1989 with the goal to<br />develop, adopt, and promote standards for the<br />development of distributed heterogeneous<br />applications.<br />☞ One of the main achievements of OMG is the<br />specification of a Common Object Request Broker<br />Architecture (CORBA).<br />• The <em>CORBA specification details the interfaces and</em><br /><em>characteristics of the Object Request Broker</em>; it<br />practically specifies the middleware functions which<br />allow application objects to communicate with one<br />another no matter where they are located, who has<br />designed them and in which language they are<br />implemented.<br />• OMG only provides a specification; there are<br />several products which, to a certain extent,<br />implement the OMG specification.<br />Distributed Systems Fö 4 &#8211; 12<br />Petru Eles, IDA, LiTH<br /><strong>CORBA (cont’d)</strong><br />• Key concepts:<br />&#8211; CORBA specifies the middleware services<br />used by the application objects.<br />&#8211; An object can be a client, a server or both.<br />&#8211; Object interaction is through requests: the information associated with a request is<br />1. an operation to be performed<br />2. a target object<br />3. zero or more parameters.<br />&#8211; CORBA supports <em>static</em> as well as <em>dynamic binding</em>; dynamic binding between objects uses runtime identification of objects and parameters.<br />&#8211; The <em>interface</em> represents the contract between<br />client and server; an IDL has been defined for<br />CORBA; proxies and skeletons (client and<br />server stubs) are generated as result of IDL<br />compilation.<br />&#8211; CORBA objects do not know the underlying implementation details; an <em>object adapter</em> maps<br />the generic model to a specific implementation.<br />Distributed Systems Fö 4 &#8211; 13<br />Petru Eles, IDA, LiTH<br /><strong>CORBA (cont’d)</strong><br />Components of a CORBA environment:<br />Client<br />Application 1<br />Client<br />Application 2 Server Object<br />Interface<br />Repository Implementation<br />Repository<br />Dynamic<br />Invocation<br />Proxy<br />(Static)<br />Server<br />Skeleton<br />Object<br />Adapter<br />Object Request Broker (ORB)<br />Distributed Systems Fö 4 &#8211; 14<br />Petru Eles, IDA, LiTH<br /><strong>Interface and Implementation Repository</strong><br />Interface Repository<br />• The interface repository provides a (standard) representation of available object interfaces for all objects in the distributed environment. It corresponds<br />to the server objects’ IDL specification.<br />• The clients can access the interface repository to<br />learn about the server objects, determine the types<br />of operations which can be invoked and the<br />corresponding parameters. This is used for<br /><em>dynamic invocation</em> of objects.<br />Implementation Repository<br />• Implementation details for the objects implementing<br />each interface are stored in the implementation<br />repository:<br />&#8211; the main information is a mapping from the server object’s name to the file name which implements the respective service;<br />&#8211; there is information concerning the object methods and information needed for method selection.<br />• Information stored in the implementation repository<br />can be specific to the operating system running on<br />the respective server object’s computer.<br />• The representation in the implementation repository<br />can be specific for a certain CORBA implementation.<br />• The implementation repository is used by the <em>object</em><br /><em>adapter</em> in order to solve an incoming call and activate the right object method (via a <em>server skeleton</em>).<br />Distributed Systems Fö 4 &#8211; 15<br />Petru Eles, IDA, LiTH<br /><strong>The Object Request Broker (ORB)</strong><br />ORB and its interfaces:<br />Dynamic<br />Invocation Proxy<br />Server<br />Skeleton Object<br />Adapter<br />Object Request Broker (ORB)<br />ORB<br />Interface<br />Client Server Object<br />ORB implementation dependent interface<br />Interface identical for all ORB implementations<br />Proxies and skeletons for each server interface<br />Distributed Systems Fö 4 &#8211; 16<br />Petru Eles, IDA, LiTH<br /><strong>The Object Request Broker (cont’d)</strong><br />☞ The ORB, through its interfaces, provides<br />mechanisms by which objects transparently interact<br />with each other.<br />• Issuing of a request from a client can be dynamic or<br />static; it is performed through the <em>proxies (client</em><br /><em>stubs)</em> or the <em>dynamic invocation interface</em>.<br />• Invocation of a specific server method is performed<br />by the server skeleton which gets the request<br />forwarded from the <em>object adapter</em>.<br />• The <em>ORB interface</em> can be accessed also <em>directly</em><br />by clients and object implementations for certain<br />services: e.g. directory services, services<br />connected to naming, manipulation of object<br />references.<br />Distributed Systems Fö 4 &#8211; 17<br />Petru Eles, IDA, LiTH<br /><strong>Static and Dynamic Invocation</strong><br />☞ CORBA allows both <em>static and dynamic invocation</em> of<br />objects. The choice is made depending on how much<br />information, concerning the server object, is available<br />at compile time.<br />Static Invocation<br />• Static invocation is based on compile time knowledge of the server’s interface specification. This<br />specification is formulated in IDL and is compiled<br />into a <em>proxy (client stub)</em>, corresponding to the programming language in which the client is encoded.<br />• For the client, an object invocation is like a local<br />invocation to a proxy method. The invocation is<br />then automatically forwarded to the object<br />implementation through the ORB, the object<br />adapter and the skeleton.<br />• Static invocation is efficient at run time, because of<br />the relatively low overhead.<br />Distributed Systems Fö 4 &#8211; 18<br />Petru Eles, IDA, LiTH<br /><strong>Static and Dynamic Invocation (cont’d)</strong><br />Dynamic Invocation<br />• Dynamic invocation allows a client to invoke<br />requests on an object without having compile-time<br />knowledge of the object’s interface.<br />• The object and its interface (methods, parameters,<br />types) are detected at run-time. CORBA provides,<br />through the <em>dynamic invocation interface</em>, the<br />mechanisms in order to inspect the <em>interface</em><br /><em>repository</em>, to dynamically construct invocations and<br />provide argument values corresponding to the<br />server’s interface specification.<br />• Once the request has been constructed and<br />arguments placed, its invocation has the same<br />effect as a static invocation.<br />• The execution overhead of a dynamic invocation is<br />huge.<br />• From the server’s point of view, static and dynamic<br />invocation are identical; the server does not know<br />how it has been invoked.<br />The server invocation is always issued through its<br />skeleton, generated at compile time from the IDL<br />specification.<br />Distributed Systems Fö 4 &#8211; 19<br />Petru Eles, IDA, LiTH<br /><strong>The Basic Object Adapter</strong><br />☞ The object adapter (OA) is the primary interface<br />between the server object implementation and the<br />ORB.<br />Services provided by the OA:<br />• Object registration: OA provides operations by<br />which certain entities, specified in a given<br />programming language, are registered as <em>CORBA</em><br /><em>objects</em>.<br />• Object reference generation: OA generates object<br />references to CORBA objects.<br />• Object upcalls: OA dispatches incoming requests to<br />the corresponding registered objects.<br />• Server process and object activation: if needed, OA<br />starts up server processes and activates objects as<br />result of incoming invocations.<br />Distributed Systems Fö 4 &#8211; 20<br />Petru Eles, IDA, LiTH<br /><strong>Other CORBA Services</strong><br />These services, and others, have been specified by the<br />CORBA documents; current products implement only<br />some of them.<br />☞ Naming and Trading Services:<br />• The basic way an object reference is generated is at<br />creation of the object when the reference is returned.<br />• Object references can be stored together with<br />associated information (e.g. names and properties).<br />• The <em>naming service</em> allows clients to find objects<br />based on names.<br />• The <em>trading service</em> allows clients to find objects<br />based on their properties.<br />☞ Transaction Management Service: provides twophase commit coordination among recoverable<br />components using transactions.<br />☞ Concurrency Control Service: provides a lock<br />manager that can obtain and free locks for<br />transactions or threads.<br />☞ Security Service: protects components from<br />unauthorized users; it provides authentication,<br />access control lists, confidentiality, etc.<br />☞ Time Service: provides interfaces for synchronizing<br />time; provides operations for defining and managing<br />time-triggered events.<br />&#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211; &#8211;<br />Distributed Systems Fö 4 &#8211; 21<br />Petru Eles, IDA, LiTH<br /><strong>Inter-ORB Architecture</strong><br />☞ Implementations of ORBs differ from vendor to<br />vendor ⇒ how do we solve interaction between<br />objects which are running on different CORBA<br />implementations?<br />• General Inter-ORB Protocol (GIOP): GIOP is defined in CORBA 2.0; it specifies a set of message<br />formats and common data representations for interactions between ORBs and is intended to operate<br />over any connection oriented transport protocol.<br />• Internet Inter-ORB Protocol (IIOP): IIOP is a<br />particularization of GIOP; it specifies how GIOP<br />messages have to be exchanged over a TCP/IP<br />network.<br />Client&Server<br />Objects<br />ORB_1 ORB_2<br />Client&Server<br />Objects<br />GIOP/IIOP<br />Distributed Systems Fö 4 &#8211; 22<br />Petru Eles, IDA, LiTH<br /><strong>Summary</strong><br />• Distributed systems are typically heterogeneous.<br />Middleware is the set of services which enable the<br />components to interact with each other without<br />taking notice of the distributed and heterogeneous<br />character of the environment.<br />• The API visible for the user of a service is defined<br />in an IDL. The IDL compiler generates proxies and<br />skeletons (client and server stubs). IDLs should be<br />implementation language independent.<br />• CORBA is the OMGs specification for an Object<br />Request Broker (ORB). Several vendors provide<br />different (partial) implementations consistent with<br />this specification.<br />• The ORB, through its interfaces, provides<br />mechanisms by which objects transparently interact<br />with each other.<br />• Objects in CORBA can be invoked statically and<br />dynamically. Static invocation is based on compile<br />time knowledge of the server’s interface<br />specification. Dynamic invocation allows a client to<br />invoke requests on an object without having<br />compile-time knowledge of the object’s interface.<br />• The object adapter is the interface between the<br />object implementation and the ORB. It provides<br />services for registration of objects and their<br />activation.<br />• CORBA 2.0 defines protocols for interaction<br />between ORBs implemented by different vendors.<br />Distributed Systems Fö 4 &#8211; 23<br />Petru Eles, IDA, LiTH<br /><strong>PEER-TO-PEER SYSTEMS</strong><br /><strong>1. Characteristics of Peer-to-Peer Systems</strong><br /><strong>2. The Napster File System</strong><br /><strong>3. BitTorrent</strong><br />Distributed Systems Fö 4 &#8211; 24<br />Petru Eles, IDA, LiTH<br /><strong>Basic Characteristics</strong><br />☞ Main characteristics of peer-to-peer systems:<br />• Each user contributes resources to the system.<br />• All the nodes have the same functional capabilities<br />and responsibilities (although they may differ in the<br />resources they contribute).<br />• Correct operation does not depend on the existence<br />of any centrally-administered system.<br />☞ Key issues:<br />• Choice of strategy for<br />&#8211; the placement of data and their replica across<br />many hosts;<br />&#8211; the access to data.<br />Such that<br />&#8211; workload of nodes and communication lines is<br />balanced;<br />&#8211; availability of data is provided.<br />☞ Anonymity of providers and users is offered (at least to<br />a certain degree).<br />Distributed Systems Fö 4 &#8211; 25<br />Petru Eles, IDA, LiTH<br /><strong>Why Do We Need It?</strong><br />☞ If only particular servers which are centrally<br />managed, can provide services/data, then scalability<br />is limited:<br />• server capacity<br />• network bandwidth provided to a server<br />☞ To avoid the scaling problem<br />• Peer-to-peer systems use the data and computing<br />resources available in the personal computers and<br />workstations present on the Internet and other<br />networks.<br />• Instead of separately managed servers, services<br />are provided by all these resources together.<br />☞ Important!<br />• Availability of individual processes/computers in a<br />peer-to-peer system is unpredictable<br />Services cannot rely on guaranteed access to a host.<br />• Availability can be improved by replication on<br />several hosts.<br />Distributed Systems Fö 4 &#8211; 26<br />Petru Eles, IDA, LiTH<br /><strong>Peer-to-Peer Systems</strong><br />First Pioneer:<br />Napster (1999)<br />Later Systems:<br />Freenet<br />Gnutella<br />Kazaa<br />BitTorrent<br />☞ The index is centralised!<br />☞ Only semi-centralised or<br />completely distributed.<br />☞ Better anonymity,<br />scalability, fault tolerance.<br />Distributed Systems Fö 4 &#8211; 27<br />Petru Eles, IDA, LiTH<br /><strong>The Napster File Sharing System</strong><br />☞ Napster provides a globally-scalable information<br />storage and retrieval service for digital music files.<br />☞ Napster was the first to demonstrate the feasibility of<br />a peer-to-peer solution on large scale.<br />☞ Napster, as an open service, was shut down July<br />2001, as result of lawsuits on copyright issues.<br />Distributed Systems Fö 4 &#8211; 28<br />Petru Eles, IDA, LiTH<br /><strong>The Napster File Sharing System (cont’d)</strong><br />Step 1: File location request;<br />Step 2: List of peers offering the files;<br />Step 3: File request;<br />Step 4: File loading;<br />Step 5: Index update (user adds own files to pool of<br />shared resources).<br />peers<br />Network<br />Napster server<br />with indexes Napster server<br />with index backups<br />1<br />2<br />5<br />3<br />4<br />Distributed Systems Fö 4 &#8211; 29<br />Petru Eles, IDA, LiTH<br /><strong>The Napster File Sharing System (cont’d)</strong><br />☞ Napster uses a centralised index (with replicas for<br />increased availability).<br />☞ The whole pool of files is distributed over the<br />personal computers of the peers.<br />☞ In order to achieve load balancing:<br />• When creating and sending the list of peers offering<br />the file (step 2), Napster takes into account locality<br />(the distance between the requesting client and the<br />potential servers).<br />Distributed Systems Fö 4 &#8211; 30<br />Petru Eles, IDA, LiTH<br /><strong>Problems with Napster</strong><br />☞ Centralised index:<br />• Scaling problem (server capacity and network<br />bandwidth).<br />• Anonymity of operators is not possible: for example,<br />legal responsibility for copyright issues can be put<br />on operators maintaining the central index.<br />☞ A completely distributed index can both provide<br />better scaling and anonymity.<br />☞ Napster did not provide particular solutions for<br />consistency of replica updates or for guaranteed<br />availability. This was no problem because of the<br />particular application, music files:<br />• Music files are immutable (they don’t change after<br />being created) ⇒ there is no need to maintain<br />replicas consistent.<br />• If a file is unavailable at a certain moment it can be<br />downloaded later.<br />☞ Second generation systems (see slide 26) have tried<br />to solve some of the above problems by applying<br />various specific, ad hoc solutions.<br />Distributed Systems Fö 4 &#8211; 31<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent</strong><br />☞ Similar to Napster, BitTorrent is a peer-to-peer filesharing application; much more decentralized as<br />Napster.<br />☞ Designed by Bram Cohen; first release 2001; several<br />versions followed.<br />☞ Main problems considered:<br />• Files are very large and if the <em>whole</em> file has to be<br />downloaded from the <em>same</em> peer this leads to poor<br />performance, processor overload, network<br />congestion.<br />So, why not <em>divide the file into chunks</em> and download<br />different chunks from <em>different</em> peers, <em>in parallel</em>?<br />• Centralised indexing creates problems with<br />scalability and availability.<br />Avoid the need for centralised indexing.<br />Distributed Systems Fö 4 &#8211; 32<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent (cont’d)</strong><br />Step 0: Search for the .torrent file and save it;<br />Step 1: The BitTorrent client on the computer contacts<br />the tracker identified in the .torrent file;<br />Step 2: The tracker identifies the corresponding swarm<br />and helps the computer join it;<br />Step 3: The computers in the swarm trade pieces of the<br />file to be downloaded; the computer receives<br />multiple pieces of the file in parallel.<br />2 1<br />3<br /><br />tracker<br />seeder<br />The initial swarm<br />(one seeder and<br />three leechers) After step 2, this<br />computer joins<br />the swarm.<br />Distributed Systems Fö 4 &#8211; 33<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent (cont’d)</strong><br />☞ A swarm is composed of several computers<br />interested in downloading/uploading a given file:<br />• <em>seeders</em>: have the complete file;<br />• <em>leechers</em>: have only a part of the file and are in the<br />process to get the whole file.<br />A swarm consists of, at least, one seeder ⇒ for a<br />download of a file to operate, at least one seeder is<br />needed to be available.<br />☞ A download begins with identifying and downloading<br />a .torrent file; the .torrent file is created and made<br />available by a user wanting to share a file;<br />• the <em>.torrent</em> file contains metadata needed for<br />downloading a certain file: name of the shared file,<br />file size, chunk size, checksum for each chunk of<br />the file (checked for integrity at download), URL of<br />the tracker.<br />Distributed Systems Fö 4 &#8211; 34<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent (cont’d)</strong><br />☞ Before being made available, a file to be distributed<br />is broken into pieces (chunks); the <em>chunk</em> size can be<br />between 64KB and 4MB.<br />• BitTorrent downloads different chunks of the file<br />simultaneously from multiple computers.<br />• As more computers in the swarm as faster<br />the download; BitTorrent is particularly useful for<br />files that are large and <em>popular</em> (many simultaneous<br />downloads).<br />• Chunks are typically received non-sequentially and<br />rearranged into the correct order (based on the<br />information from the .torrent file) by the receiving<br />client.<br />☞ The <em>tracker</em> is the computer in charge of managing<br />the transfer of a particular file:<br />• The tracker’s URL is extracted from the .torrent file.<br />• It keeps track of the connected computers; it<br />facilitates the computers in the swarm to connect to<br />each other by sharing their IP addresses.<br />• Attention: the file is not downloaded from the<br />tracker! The tracker only coordinates the swarm.<br />☞ The concrete way how you identify the .torrent file<br />corresponding to the actual file you are interested in,<br />is not part of the protocol. You can google, or go to<br />specialised pages (e.g. PiratBay, but also many other<br />less controversial ones), etc.<br />Distributed Systems Fö 4 &#8211; 35<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent (cont’d)</strong><br />Tit-for-tat reward system<br />The reward system tries to avoid peers only downloading<br />but not contributing with uploading:<br />• In order to receive files, you also have to give;<br />clients reward other clients who upload, preferring<br />to send data to clients who contribute more upload<br />bandwidth ⇒ the more files you share with others,<br />the faster your downloads are.<br />• After you have got the whole file, you should<br />continue to run the client ⇒ you stay as a potential<br />seeder which others can use ⇒ your rates improve<br />in the tit-for-tat system.<br />Distributed Systems Fö 4 &#8211; 36<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent: Scaling, Availability, Developments</strong><br />☞ Napster:<br />• centralized indexing service (if it fails ⇒ );<br />• the whole file is downloaded (sequentially) from the<br />same peer (if it fails ⇒ ).<br />Potentially reduced scalability and availability.<br />☞ BitTorrent:<br />• no indexing system (you just need a .torrent file);<br />• pieces of the file are downloaded (in parallel) from<br />multiple seeders and leachers from the swarm.<br />Increased scalability, availability, performance.<br />Distributed Systems Fö 4 &#8211; 37<br />Petru Eles, IDA, LiTH<br /><strong>BitTorrent: Scaling, Availability, Developments</strong><br /><strong>(cont’d)</strong><br />☞ A potential point of failure is the tracker supervising<br />the swarm!<br />Two alternative solutions are proposed in later versions:<br />• A decentralized, trackerless torrent system:<br />Clients communicate to each other without a<br />central tracker; a distributed hash table (DHT)<br />technique is used, by which nodes identify other<br />nodes to build the swarm. The swarm is managed<br />collectively by its members.<br />• Multi-tracker implementations:<br />Multiple trackers can be used for one torrent; they<br />are specified on the .torrent file.<br />Distributed Systems Fö 4 &#8211; 38<br />Petru Eles, IDA, LiTH<br /><strong>Summary</strong><br />• Peer-to peer systems are a possible solution for the<br />scaling problems with traditional client-server<br />systems.<br />• Scaling in peer-to-peer systems is solved by<br />exploiting the resources available on the personal<br />computers and workstations available in the<br />network, instead of using dedicated and centrally<br />maintained servers.<br />• Napster has been the first widely used peer-to-peer<br />system. While the pool of files is completely<br />distributed over the personal computers of the<br />hosts, Napster is still using a centralised index. This<br />has consequences with regard to both scaling and<br />anonymity.<br />• BitTorrent has solved some of Napster’s<br />shortcomings and increased both availability and<br />performance. There is no centralised indexing<br />system and downloads are performed in<br />cooperation and in parallel by members of a swarm.<br /></span><br class="Apple-interchange-newline" />