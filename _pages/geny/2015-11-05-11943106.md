---
id: 78
title: 'DISTRIBUTED SYSTEMS: LECTURE 9-10'
date: 2015-11-05T13:26:00+00:00
author: chito
layout: post
guid: http://www.afriqueunique.org/2015/11/05/11943106/
permalink: /2015/11/05/11943106/
swp_pinterest_image_url:
  - ""
swp_cache_timestamp:
  - "419230"
post_views_count:
  - "150"
bs_social_share_facebook:
  - "0"
bs_social_share_twitter:
  - "0"
bs_social_share_reddit:
  - "0"
bs_social_share_google_plus:
  - "0"
bs_social_share_linkedin:
  - "0"
bs_social_share_interval:
  - "1568724954"
categories:
  - LEARNING
---
<span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 1<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:10pt;"><strong>FAULT TOLERANCE</strong><br /><span style="font-size:8pt;"><strong>1. Fault Tolerant Systems</strong><br /><span style="font-size:8pt;"><strong>2. Faults and Fault Models</strong><br /><span style="font-size:8pt;"><strong>3. Redundancy</strong><br /><span style="font-size:8pt;"><strong>4. Time Redundancy and Backward Recovery</strong><br /><span style="font-size:8pt;"><strong>5. Hardware Redundancy</strong><br /><span style="font-size:8pt;"><strong>6. Software Redundancy</strong><br /><span style="font-size:8pt;"><strong>7. Distributed Agreement with Byzantine Faults</strong><br /><span style="font-size:8pt;"><strong>8. The Byzantine Generals Problem</strong><br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 2<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:9pt;"><strong>Fault Tolerant Systems</strong><br /><span style="font-size:8pt;">☞ A system fails if it behaves in a way which is not<br /><span style="font-size:8pt;">consistent with its specification. Such a <span style="font-size:8pt;"><em>failure</em> <span style="font-size:8pt;">is a<br /><span style="font-size:8pt;">result of a <span style="font-size:8pt;"><em>fault</em> <span style="font-size:8pt;">in a system component.<br /><span style="font-size:8pt;">☞ Systems are <span style="font-size:8pt;"><em>fault-tolerant</em> <span style="font-size:8pt;">if they behave in a<br /><span style="font-size:8pt;">predictable manner, according to their specification,<br /><span style="font-size:8pt;">in the presence of faults ⇒ there are no failures in a<br /><span style="font-size:8pt;">fault tolerant system.<br /><span style="font-size:8pt;">☞ Several application areas need systems to maintain a<br /><span style="font-size:8pt;">correct (predictable) functionality in the presence of<br /><span style="font-size:8pt;">faults:<br /><span style="font-size:8pt;">&#8211; banking systems<br /><span style="font-size:8pt;">&#8211; control systems<br /><span style="font-size:8pt;">&#8211; manufacturing systems<br /><span style="font-size:8pt;">☞ What means correct functionality in the presence of<br /><span style="font-size:8pt;">faults?<br /><span style="font-size:8pt;">The answer depends on the particular application (on<br /><span style="font-size:8pt;">the specification of the system):<br /><span style="font-size:8pt;">• The system stops and doesn’t produce any<br /><span style="font-size:8pt;">erroneous (dangerous) result/behaviour.<br /><span style="font-size:8pt;">• The system stops and restarts after a while<br /><span style="font-size:8pt;">without loss of information.<br /><span style="font-size:8pt;">• The system keeps functioning without any<br /><span style="font-size:8pt;">interruption and (possibly) with unchanged<br /><span style="font-size:8pt;">performance.<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 3<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:9pt;"><strong>Faults</strong><br /><span style="font-size:8pt;">☞ A fault can be:<br /><span style="font-size:8pt;">1. Hardware fault: malfunction of a hardware<br /><span style="font-size:8pt;">component (processor, communication line,<br /><span style="font-size:8pt;">switch, etc.).<br /><span style="font-size:8pt;">2. Software fault: malfunction due to a software<br /><span style="font-size:8pt;">bug.<br /><span style="font-size:8pt;">☞ A fault can be the result of:<br /><span style="font-size:8pt;">1. Mistakes in specification or design: such mistakes are at the origin of all software faults and<br /><span style="font-size:8pt;">of some of the hardware faults.<br /><span style="font-size:8pt;">2. Defects in components: hardware faults can be<br /><span style="font-size:8pt;">produced by manufacturing defects or by<br /><span style="font-size:8pt;">defects caused as result of deterioration in the<br /><span style="font-size:8pt;">course of time.<br /><span style="font-size:8pt;">3. Operating environment: hardware faults can be<br /><span style="font-size:8pt;">the result of stress produced by adverse environment: temperature, radiation, vibration, etc.<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 4<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:8pt;"><strong>Faults (cont’d)</strong><br /><span style="font-size:8pt;">☞ Fault types according to their temporal behavior:<br /><span style="font-size:8pt;">1. Permanent fault: the fault remains until it is repaired or the affected unit is replaced.<br /><span style="font-size:8pt;">2. Intermittent fault: the fault vanishes and reappears (e.g. caused by a loose wire).<br /><span style="font-size:8pt;">3. Transient fault: the fault dies away after some<br /><span style="font-size:8pt;">time (caused by environmental effects).<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 5<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:8pt;"><strong>Faults (cont’d)</strong><br /><span style="font-size:8pt;">☞ Fault types according to their output behaviour:<br /><span style="font-size:8pt;">1. Fail-stop fault: either the processor is executing<br /><span style="font-size:8pt;">and can participate with correct values, or it has<br /><span style="font-size:8pt;">failed and will never respond to any request<br /><span style="font-size:8pt;">(see omission faults, Fö 2, slide 20).<br /><span style="font-size:8pt;">Working processors can detect the failed<br /><span style="font-size:8pt;">processor by a <span style="font-size:8pt;"><em>time-out mechanism</em><span style="font-size:8pt;">.<br /><span style="font-size:8pt;">2. Slowdown fault: it differs from the fail-stop<br /><span style="font-size:8pt;">model in the sense that a processor might fail<br /><span style="font-size:8pt;">and stop or it might execute slowly for a while<br /><span style="font-size:8pt;">⇒ there is no time-out mechanism to make<br /><span style="font-size:8pt;">sure that a processor has failed; it might be incorrectly labelled as failed and we can be in<br /><span style="font-size:8pt;">trouble when it comes back (take care it<br /><span style="font-size:8pt;">doesn’t come back unexpectedly).<br /><span style="font-size:8pt;">3. Byzantine fault: a process can fail and stop, execute slowly, or execute at a normal speed but<br /><span style="font-size:8pt;">produce erroneous values and actively try to<br /><span style="font-size:8pt;">make the computation fail ⇒ any message can<br /><span style="font-size:8pt;">be corrupt and has to be decided upon by a<br /><span style="font-size:8pt;">group of processors (see arbitrary faults, Fö<br /><span style="font-size:8pt;">2, slide 21).<br /><span style="font-size:8pt;">• The <span style="font-size:8pt;"><em>fail-stop</em> <span style="font-size:8pt;">model is the easiest to handle;<br /><span style="font-size:8pt;">unfortunately, sometimes it is too simple to cover<br /><span style="font-size:8pt;">real situations.<br /><span style="font-size:8pt;">• The <span style="font-size:8pt;"><em>byzantine</em> <span style="font-size:8pt;">model is the most general; it is very<br /><span style="font-size:8pt;">expensive, in terms of complexity, to implement<br /><span style="font-size:8pt;">fault-tolerant algorithms based on this model.<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 6<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:8pt;"><strong>Faults (cont’d)</strong><br /><span style="font-size:8pt;">☞ A fault type specifically related to the communication<br /><span style="font-size:8pt;">media in a distributed system:<br /><span style="font-size:8pt;">• Partition Fault<br /><span style="font-size:8pt;">Two processes, which need to interact, are unable<br /><span style="font-size:8pt;">to communicate with each other because there<br /><span style="font-size:8pt;">exists no direct or indirect link between them ⇒ the<br /><span style="font-size:8pt;">processes belong to different <span style="font-size:8pt;"><em>network partitions</em><span style="font-size:8pt;">.<br /><span style="font-size:8pt;">Partition faults can be due to:<br /><span style="font-size:8pt;">&#8211; broken communication wire<br /><span style="font-size:8pt;">&#8211; congested communication link.<br /><span style="font-size:8pt;">A possible very dangerous consequence:<br /><span style="font-size:8pt;">&#8211; Processes in one network partition could<br /><span style="font-size:8pt;">believe that there are no other working<br /><span style="font-size:8pt;">processes in the system.<br /><span style="font-size:8pt;">P7 P2 P5<br /><span style="font-size:8pt;">P8<br /><span style="font-size:8pt;">P3<br /><span style="font-size:8pt;">P4<br /><span style="font-size:8pt;">P1<br /><span style="font-size:8pt;">P6<br /><span style="font-size:8pt;"><em>network partition network partition</em><br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 7<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:9pt;"><strong>Redundancy</strong><br /><span style="font-size:8pt;">☞ If a system has to be fault-tolerant, it has to be<br /><span style="font-size:8pt;">provided with spare capacity ⇒ redundancy:<br /><span style="font-size:8pt;">1. Time redundancy: the timing of the system is<br /><span style="font-size:8pt;">such, that if certain tasks have to be rerun and<br /><span style="font-size:8pt;">recovery operations have to be performed,<br /><span style="font-size:8pt;">system requirements are still fulfilled.<br /><span style="font-size:8pt;">2. Hardware redundancy: the system is provided<br /><span style="font-size:8pt;">with far more hardware than needed for basic<br /><span style="font-size:8pt;">functionality.<br /><span style="font-size:8pt;">3. Software redundancy: the system is provided<br /><span style="font-size:8pt;">with different software versions:<br /><span style="font-size:8pt;">&#8211; results produced by different versions are<br /><span style="font-size:8pt;">compared;<br /><span style="font-size:8pt;">&#8211; when one version fails another one can<br /><span style="font-size:8pt;">take over.<br /><span style="font-size:8pt;">4. Information redundancy: data are coded in<br /><span style="font-size:8pt;">such a way that a certain number of bit errors<br /><span style="font-size:8pt;">can be detected and, possibly, corrected (parity coding, checksum codes, cyclic codes).<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 8<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:9pt;"><strong>Time Redundancy and Backward Recovery</strong><br /><span style="font-size:8pt;">☞ The basic idea with <span style="font-size:8pt;"><em>backward recovery</em> <span style="font-size:8pt;">is to roll back<br /><span style="font-size:8pt;">the computation to a previous checkpoint and to<br /><span style="font-size:8pt;">continue from there.<br /><span style="font-size:8pt;">☞ Essential aspects:<br /><span style="font-size:8pt;">1. Save <span style="font-size:8pt;"><em>consistent</em> <span style="font-size:8pt;">states of the distributed system, which can serve as recovery points.<br /><span style="font-size:8pt;">Maintain replicated copies of data.<br /><span style="font-size:8pt;">2. Recover the system from a recent recovery<br /><span style="font-size:8pt;">point and take the needed corrective action.<br /><span style="font-size:8pt;">• Creating globally coherent checkpoints for a<br /><span style="font-size:8pt;">distributed systems is, in general, performed based<br /><span style="font-size:8pt;">on strategies similar to those discussed in Fö 5 for<br /><span style="font-size:8pt;"><em>Global States</em> <span style="font-size:8pt;">and <span style="font-size:8pt;"><em>Global State Recording</em><span style="font-size:8pt;">.<br /><span style="font-size:8pt;">• For managing coherent replicas of data (files) see<br /><span style="font-size:8pt;">Fö 8.<br /><span style="font-size:8pt;">• Corrective action:<br /><span style="font-size:8pt;">&#8211; Carry on with the same processor and software<br /><span style="font-size:8pt;">(a transient fault is assumed).<br /><span style="font-size:8pt;">&#8211; Carry on with a new processor (a permanent<br /><span style="font-size:8pt;">hardware fault is assumed).<br /><span style="font-size:8pt;">&#8211; Carry on with the same processor and another<br /><span style="font-size:8pt;">software version (a permanent software fault is<br /><span style="font-size:8pt;">assumed).<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 9<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:8pt;"><strong>Time Redundancy and Backward Recovery (cont’d)</strong><br /><span style="font-size:8pt;">Recovery in transaction-based systems<br /><span style="font-size:8pt;">Transaction-based systems have particular features<br /><span style="font-size:8pt;">related to recovery:<br /><span style="font-size:8pt;">☞ A <span style="font-size:8pt;"><em>transaction</em> <span style="font-size:8pt;">is a sequence of operations (that virtually forms a single step), transforming data from one<br /><span style="font-size:8pt;">consistent state to another.<br /><span style="font-size:8pt;">Transactions are applied to <span style="font-size:8pt;"><em>recoverable data</em> <span style="font-size:8pt;">and<br /><span style="font-size:8pt;">their main characteristic is <span style="font-size:8pt;"><em>atomicity</em><span style="font-size:8pt;">:<br /><span style="font-size:8pt;">• <span style="font-size:8pt;"><em>All-or-nothing</em> <span style="font-size:8pt;">semantics: a transaction either<br /><span style="font-size:8pt;">completes successfully and the effects of all of<br /><span style="font-size:8pt;">its operations are recorded in the data items,<br /><span style="font-size:8pt;">or it fails and then has no effect at all.<br /><span style="font-size:8pt;">&#8211; <span style="font-size:8pt;"><em>Failure atomicity</em><span style="font-size:8pt;">: the effects are atomic<br /><span style="font-size:8pt;">even when the server fails.<br /><span style="font-size:8pt;">&#8211; <span style="font-size:8pt;"><em>Durability</em><span style="font-size:8pt;">: after a transaction has completed successfully all its effects are saved in<br /><span style="font-size:8pt;">permanent storage (this data survives<br /><span style="font-size:8pt;">when the server process crashes).<br /><span style="font-size:8pt;">• Isolation: The intermediate effects of a transaction are not visible to any other transaction.<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 10<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:8pt;"><strong>Time Redundancy and Backward Recovery (cont’d)</strong><br /><span style="font-size:8pt;">☞ <span style="font-size:8pt;"><em>Transaction processing implicitly means recoverability</em><span style="font-size:8pt;">:<br /><span style="font-size:8pt;">• When a server fails, the changes due to all<br /><span style="font-size:8pt;">completed transactions must be available in<br /><span style="font-size:8pt;">permanent storage ⇒ the server can recover<br /><span style="font-size:8pt;">with data available according to <span style="font-size:8pt;"><em>all-or-nothing</em><br /><span style="font-size:8pt;">semantics.<br /><span style="font-size:8pt;">☞ <span style="font-size:8pt;"><em>Two-phase commitment</em><span style="font-size:8pt;">, <span style="font-size:8pt;"><em>concurrency control</em><span style="font-size:8pt;">, and <span style="font-size:8pt;"><em>recovery system</em> <span style="font-size:8pt;">are the key aspects for implementing<br /><span style="font-size:8pt;">transaction processing in distributed systems.<br /><span style="font-size:8pt;">See data-base course!<br /><span style="font-size:4pt;">Distributed Systems Fö 9/10 &#8211; 11<br /><span style="font-size:5pt;">Petru Eles, IDA, LiTH<br /><span style="font-size:9pt;"><strong>Forward Recovery</strong><br /><span style="font-size:8pt;">☞ Backward recovery is based on time redundancy and<br /><span style="font-size:8pt;">on the availability of back-up files and saved<br /><span style="font-size:8pt;">checkpoints; this is expansive in terms of time.<br /><span style="font-size:8pt;">☞ The basic fault model behind transaction processing<br /><span style="font-size:8pt;">and backward recovery is the fail-stop model<br /><span style="font-size:8pt;">☞ Control applications and, in general, real-time<br /><span style="font-size:8pt;">systems have very strict timing requirements.<br /><span style="font-size:8pt;">Recovery has to be very fast and preferably to be<br /><span style="font-size:8pt;">continued from the current state. For such<br /><span style="font-size:8pt;">applications, which often are safety critical, the failstop model is not realistic.<br /><span style="font-size:8pt;"><em>Forward recovery</em><span style="font-size:8pt;">: the error is masked without any<br /><span style="font-size:8pt;">computations having to be redone.<br /><span style="font-size:8pt;">☞ Forward recovery is mainly based on hardware and,<br /></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>