---
id: 85
title: 'DISTRIBUTED SYSTEMS: LECTURE 2'
date: 2015-11-05T11:44:00+00:00
author: chito
layout: post
guid: http://www.afriqueunique.org/2015/11/05/11942234/
permalink: /2015/11/05/11942234/
swp_pinterest_image_url:
  - ""
swp_cache_timestamp:
  - "419230"
post_views_count:
  - "199"
bs_social_share_facebook:
  - "0"
bs_social_share_twitter:
  - "0"
bs_social_share_reddit:
  - "0"
bs_social_share_google_plus:
  - "0"
bs_social_share_linkedin:
  - "0"
bs_social_share_interval:
  - "1568477412"
categories:
  - LEARNING
---
<span style="font-size:small;">Distributed Systems Fö 2 &#8211; 1<br />Petru Eles, IDA, LiTH<br /><strong>MODELS OF DISTRIBUTED SYSTEMS</strong><br /><strong>1. Architectural Models</strong><br /><strong>2. Interaction Models</strong><br /><strong>3. Fault Models</strong><br />Distributed Systems Fö 2 &#8211; 2<br />Petru Eles, IDA, LiTH<br /><strong>Basic Elements</strong><br />• <strong>Resources</strong> in a distributed system are shared<br />between <strong>users</strong>. They are normally encapsulated<br />within one of the computers and can be accessed<br />from other computers by communication.<br />• Each resource is managed by a program, the<br /><em>resource manager</em>; it offers a communication<br />interface enabling the resource to be accessed by<br />its users.<br />• Resource managers can be in general modelled as<br /><em>processes</em>.<br />If the system is designed according to an objectoriented methodology, resources are encapsulated<br />in <em>objects</em>.<br />Distributed Systems Fö 2 &#8211; 3<br />Petru Eles, IDA, LiTH<br /><strong>Architectural Models</strong><br />How are responsibilities distributed between system<br />components and how are these components placed?<br />• Client-server model<br />• Peer-to-peer<br />Variations of the above two:<br />• Proxy server<br />• Mobile code<br />• Mobile agents<br />• Network computers<br />• Thin clients<br />• Mobile devices<br />Distributed Systems Fö 2 &#8211; 4<br />Petru Eles, IDA, LiTH<br /><strong>Client &#8211; Server</strong><br />☞ The system is structured as a set of processes,<br />called <em>servers</em>, that offer services to the users, called<br /><em>clients</em>.<br />• The client-server model is usually based on a<br />simple request/reply protocol, implemented with<br /><em>send</em>/<em>receive</em> primitives or using <em>remote procedure</em><br /><em>calls</em> (RPC) or <em>remote method invocation</em> (RMI):<br />&#8211; the client sends a request (invocation) message<br />to the server asking for some service;<br />&#8211; the server does the work and returns a result<br />(e.g. the data requested) or an error code if the<br />work could not be performed.<br />Distributed Systems Fö 2 &#8211; 5<br />Petru Eles, IDA, LiTH<br /><strong>Client &#8211; Server (cont’d)</strong><br />• A server can itself request services from other<br />servers; thus, in this new relation, the server itself<br />acts like a client.<br />client<br />client<br />client<br />server<br />server<br />request:<br />result:<br />process (object):<br />computer (node):<br />Distributed Systems Fö 2 &#8211; 6<br />Petru Eles, IDA, LiTH<br /><strong>Peer-to-Peer</strong><br />☞ All processes (objects) play similar role.<br />• Processes (objects) interact without particular<br />distinction between clients and servers.<br />• The pattern of communication depends on the<br />particular application.<br />• A large number of data objects are shared; any<br />individual computer holds only a small part of the<br />application database.<br />• Processing and communication loads for access to<br />objects are distributed across many computers and<br />access links.<br />• This is the most general and flexible model.<br />peer peer<br />peer peer<br />Distributed Systems Fö 2 &#8211; 7<br />Petru Eles, IDA, LiTH<br /><strong>Peer-to-Peer (cont’d)</strong><br />☞ Some problems with client-server:<br />• Centralisation of service ⇒ poor scaling<br />&#8211; Limitations:<br />capacity of server<br />bandwidth of network connecting the server<br />☞ Peer-to-Peer tries to solve some of the above<br />• It distributes shared resources widely<br />share computing and communication loads.<br />☞ Problems with peer-to-peer:<br />• High complexity due to<br />&#8211; cleverly place individual objects<br />&#8211; retrieve the objects<br />&#8211; maintain potentially large number of replicas.<br />Distributed Systems Fö 2 &#8211; 8<br />Petru Eles, IDA, LiTH<br /><strong>Variations of the Basic Models</strong><br />☞ Client-server and peer-to-peer can be considered as<br />basic models.<br />• Several variations have been proposed, with<br />considering factors such as:<br />&#8211; multiple servers and caches<br />&#8211; mobile code and mobile agents<br />&#8211; low-cost computers at the users’ side<br />&#8211; mobile devices<br />Distributed Systems Fö 2 &#8211; 9<br />Petru Eles, IDA, LiTH<br /><strong>Proxy Server</strong><br />☞ A proxy server provides copies (replications) of<br />resources which are managed by other servers.<br />• Proxy servers are typically used as caches for web<br />resources. They maintain a cache of recently<br />visited web pages or other resources.<br />When a request is issued by a client, the proxy<br />server is first checked, if the requested object<br />(information item) is available there.<br />• Proxy servers can be located at each client, or can<br />be shared by several clients.<br />• The purpose is to increase performance and<br />availability, by avoiding frequent accesses to<br />remote servers.<br />client<br />client<br />proxy<br />server<br />server<br />server<br />Distributed Systems Fö 2 &#8211; 10<br />Petru Eles, IDA, LiTH<br /><strong>Mobile Code</strong><br />☞ Mobile code: code that is sent from one computer to<br />another and run at the destination.<br />Advantage: remote invocations are replaced by local ones.<br />Typical example: Java applets.<br />client server<br />applet code<br />client applet server<br />Step 1: load applet<br />Step 2: interact with applet<br />Distributed Systems Fö 2 &#8211; 11<br />Petru Eles, IDA, LiTH<br /><strong>Mobile Agents</strong><br />☞ Mobile agent: a running program that travels from<br />one computer to another carrying out a task on<br />someone’s behalf.<br />• A mobile agent is a complete program, code + data,<br />that can work (relatively) independently.<br />• The mobile agent can invoke local resources/data.<br />Typical tasks:<br />• Collect information<br />• Install/maintain software on computers<br />• Compare prises from various vendors bay visiting<br />their sites.<br />Attention: potential security risk (like mobile code)!<br />Distributed Systems Fö 2 &#8211; 12<br />Petru Eles, IDA, LiTH<br /><strong>Network Computers</strong><br />☞ Network computers do not store locally operating<br />system or application code. All code is loaded from<br />the servers and run locally on the network computer.<br />Advantages:<br />• The network computer can be simpler, with limited<br />capacity; it does not need even a local hard disk (if<br />there exists one it is used to cache data or code).<br />• Users can log in from any computer.<br />• No user effort for software management/<br />administration.<br />Network computers<br />Network<br />servers<br />Distributed Systems Fö 2 &#8211; 13<br />Petru Eles, IDA, LiTH<br /><strong>Thin Clients</strong><br />☞ The thin client is a further step, beyond the network<br />computer:<br />• Thin clients do not download code (operating<br />system or application) from the server to run it<br />locally. <em>All code is run on the server, in parallel for</em><br /><em>several clients</em>.<br />• The thin client only runs the user interface!<br />Advantages:<br />• All those of network computers but the computer at<br />the user side is even simpler (cheaper).<br />☞ Strong servers are needed!<br />Distributed Systems Fö 2 &#8211; 14<br />Petru Eles, IDA, LiTH<br /><strong>Mobile Devices</strong><br />☞ Mobile devices are hardware, computing<br />components that move (together with their software)<br />between physical locations.<br />• This is opposed to software agents, which are<br />software components that migrate.<br />• Both clients and servers can be mobile (clients<br />more frequently).<br />☞ Particular problems/issues:<br />• Mobility transparency: clients should not be aware if<br />the server moves (e.g., the server keeps its Internet<br />address even if it moves between networks).<br />• Problems due to variable connectivity and<br />bandwidth.<br />• The device has to explore its environment:<br />&#8211; Spontaneous interoperation: associations<br />between devices (e.g. clients and servers) are<br />dynamically created and destroyed.<br />&#8211; Context awareness: available services are<br />dependent on the physical environment in<br />which the device is situated.<br />Distributed Systems Fö 2 &#8211; 15<br />Petru Eles, IDA, LiTH<br /><strong>Interaction Models</strong><br />How do we handle time? Are there time limits on process<br />execution, message delivery, and clock drifts?<br />• Synchronous distributed systems<br />• Asynchronous distributed systems<br />Distributed Systems Fö 2 &#8211; 16<br />Petru Eles, IDA, LiTH<br /><strong>Synchronous Distributed Systems</strong><br />Main features:<br />• Lower and upper bounds on execution time of<br />processes can be set.<br />• Transmitted messages are received within a known<br />bounded time.<br />• Drift rates between local clocks have a known<br />bound.<br />Important consequences:<br />1. In a synchronous distributed system there is a<br />notion of global physical time (with a known relative<br />precision depending on the drift rate).<br />2. Only synchronous distributed systems have a<br />predictable behaviour in terms of timing. <em>Only such</em><br /><em>systems can be used for hard real-time</em><br /><em>applications</em>.<br />3. In a synchronous distributed system it is possible<br />and safe to use timeouts in order to detect failures<br />of a process or communication link.<br />☞ It is difficult and costly to implement synchronous<br />distributed systems.<br />Distributed Systems Fö 2 &#8211; 17<br />Petru Eles, IDA, LiTH<br /><strong>Asynchronous Distributed Systems</strong><br />☞ Many distributed systems (including those on the<br />Internet) are asynchronous.<br />• No bound on process execution time (nothing can<br />be assumed about speed, load, reliability of<br />computers).<br />• No bound on message transmission delays<br />(nothing can be assumed about speed, load,<br />reliability of interconnections)<br />• No bounds on drift rates between local clocks.<br />Important consequences:<br />1. In an asynchronous distributed system there is no<br />global physical time. Reasoning can be only in<br />terms of logical time (see lecture on time and<br />state).<br />2. Asynchronous distributed systems are<br />unpredictable in terms of timing.<br />3. No timeouts can be used.<br />Distributed Systems Fö 2 &#8211; 18<br />Petru Eles, IDA, LiTH<br /><strong>Asynchronous Distributed Systems (cont’d)</strong><br />☞ Asynchronous systems are widely and successfully<br />used in practice.<br />In practice timeouts are used with asynchronous<br />systems for failure detection.<br />However, additional measures have to be applied in<br />order to avoid duplicated messages, duplicated<br />execution of operations, etc.<br />Distributed Systems Fö 2 &#8211; 19<br />Petru Eles, IDA, LiTH<br /><strong>Fault Models</strong><br />What kind of faults can occur and what are their effects?<br />• Omission faults<br />• Arbitrary faults<br />• Timing faults<br />☞ Faults can occur both in processes and<br />communication channels. The reason can be both<br />software and hardware faults.<br />☞ Fault models are needed in order to build systems<br />with predictable behaviour in case of faults (systems<br />which are fault tolerant).<br />☞ Of course, such a system will function according to<br />the predictions, only as long as the real faults behave<br />as defined by the “fault model”. If not &#8230;&#8230;.<br />☞ These issues will be discussed in some of the<br />following chapters and in particular in the chapter on<br />“Recovery and Fault Tolerance”.<br />Distributed Systems Fö 2 &#8211; 20<br />Petru Eles, IDA, LiTH<br /><strong>Omission Faults</strong><br />☞ A processor or communication channel fails to<br />perform actions it is supposed to do.<br />This means that the particular action is not performed!<br />• We do not have an omission fault if:<br />&#8211; An action is delayed (regardless how long) but<br />finally executed.<br />&#8211; An action is executed with an erroneous result.<br />☞ With synchronous systems, omission faults can be<br />detected by timeouts.<br />• If we are sure that messages arrive, a timeout<br />will indicate that the sending process has<br />crashed. Such a system has a <em>fail-stop</em><br />behaviour.<br />Distributed Systems Fö 2 &#8211; 21<br />Petru Eles, IDA, LiTH<br /><strong>Arbitrary (Byzantine) Faults</strong><br />☞ This is the most general and worst possible fault<br />semantics.<br />Intended processing steps or communications are<br />omitted or/and unintended ones are executed.<br />Results may not come at all or may come but carry<br />wrong values.<br /><strong>Timing Faults</strong><br />☞ Timing faults can occur in synchronous distributed<br />systems, where time limits are set to process<br />execution, communications, and clock drifts.<br />A timing fault occurs if any of this time limits is<br />exceeded.<br />Distributed Systems Fö 2 &#8211; 22<br />Petru Eles, IDA, LiTH<br /><strong>Summary</strong><br />• Models can be used to provide an abstract and<br />simplified description of certain relevant aspects of<br />distributed systems.<br />• Architectural models define the way responsibilities<br />are distributed among components and how they<br />are placed in the system.<br />We have studied three architectural models:<br />1. Client-server model<br />2. Peer-to-peer<br />3. Several variations of the two<br />• Interaction models deal with how time is handled<br />throughout the system.<br />Two interaction models have been introduced:<br />1. Synchronous distributed systems<br />2. Asynchronous distributed systems<br />• The fault model specifies what kind of faults can<br />occur and what their effects are.<br />Fault models:<br />1. Omission faults<br />2. Arbitrary faults<br />3. Timing faults<br /></span><br class="Apple-interchange-newline" />